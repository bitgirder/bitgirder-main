package com.bitgirder.crypto;

import com.bitgirder.validation.Inputs;
import com.bitgirder.validation.State;

import com.bitgirder.lang.Lang;

import com.bitgirder.log.CodeLoggers;

import com.bitgirder.io.IoUtils;
import com.bitgirder.io.IoTests;
import com.bitgirder.io.Charsets;

import com.bitgirder.test.Test;

import java.util.Map;

import java.security.KeyStore;

import java.nio.ByteBuffer;

import javax.crypto.Mac;
import javax.crypto.SecretKey;
import javax.crypto.KeyGenerator;

import javax.crypto.spec.IvParameterSpec;

@Test
public
final
class CryptoTests
{
    private static Inputs inputs = new Inputs();
    private static State state = new State();

    private static void code( Object... msg ) { CodeLoggers.code( msg ); }

    // Taken from the sample key in the AWS S3 docs, for what that's worth
    private final static String TEST_KEY_ASCII = 
        "uV3F3YluFJax1cknvbcGwgjvx4QpvB+leU8dUj2o";

    // Include the \n in HELLO_STR since we obtain HELLO_MD5_EXPCT from the
    // command: 'echo "hello" | openssl md5 -c'
    private final static String HELLO_STR = "hello\n";
    private final static ByteBuffer HELLO_MD5_EXPCT;

    @Test
    private
    void
    testMd5UtilMethod()
        throws Exception
    {
        ByteBuffer src = ByteBuffer.wrap( HELLO_STR.getBytes( "UTF-8" ) );
        ByteBuffer md5 = CryptoUtils.getMd5( src );
        
        state.equal( HELLO_MD5_EXPCT, md5 );
    }

    @Test
    private
    void
    testMessageDigesterSingleCall()
        throws Exception
    {
        ByteBuffer src = ByteBuffer.wrap( HELLO_STR.getBytes( "UTF-8" ) );
        MessageDigester dig = CryptoUtils.createDigester( "md5" );

        dig.update( src );
        state.equal( HELLO_MD5_EXPCT, dig.digest() );
    }

    @Test
    private
    void
    testMessageDigesterMultiBufs()
        throws Exception
    {
        ByteBuffer src = ByteBuffer.wrap( HELLO_STR.getBytes( "UTF-8" ) );
        MessageDigester dig = CryptoUtils.createDigester( "md5" );

        ByteBuffer b1 = src.duplicate();
        b1.limit( 2 );

        ByteBuffer b2 = src.duplicate();
        b2.position( 2 );

        ByteBuffer md5 = IoUtils.digest( dig, true, b1, b2 );

        state.equal( HELLO_MD5_EXPCT, md5 );
    }

    // Expected string was generated by the command:
    //
    //  $ echo "sign-this-string" | openssl dgst -sha256 -hmac 'uV3F3YluFJax1cknvbcGwgjvx4QpvB+leU8dUj2o'
    //
    @Test
    private
    void
    testHmacSha256()
        throws Exception
    {
        SecretKey key = CryptoUtils.asSecretKey( TEST_KEY_ASCII, "HmacSHA256" );
        Mac mac = CryptoUtils.expectMac( key, "HmacSHA256" );

        ByteBuffer toSign = Charsets.UTF_8.asByteBuffer( "sign-this-string\n" );
        ByteBuffer sig = CryptoUtils.sign( toSign, mac );

        state.equalString( 
            "4a6a1d3ecc981c8fde0aa8d98b88d9d164d45978454875fa44fdf2f3c1464e9a", 
            IoUtils.asHexString( sig )
        );
    }

    @Test
    private
    void
    testGetAlgorithm()
    {
        // Not all of the transform strings tested below are actually valid from
        // a JCE perspective, but we only care about asserting our parsing of
        // them
        for ( String s : 
                new String[] { "AES", "AES/CBC", "AES/CBC/PKCS5Padding" } )
        {
            state.equalString( "AES", CryptoUtils.getAlgorithm( s ) );
        }
    }

    @Test( expected = IllegalArgumentException.class,
           expectedPattern = 
            "Cannot determine algorithm name in transformation: " )
    private
    void
    testGetAlgorithmWithEmptyAlgNameFails()
    {
        CryptoUtils.getAlgorithm( "" );
    }

    @Test( expected = IllegalArgumentException.class,
           expectedPattern = 
            "Cannot determine algorithm name in transformation: " +
            "/CBC/NoPadding" )
    private
    void
    testGetAlgorithmWithMissingAlgNameFails()
    {
        CryptoUtils.getAlgorithm( "/CBC/NoPadding" );
    }

    @Test( expected = IllegalStateException.class,
           expectedPattern = 
            "\\QUnrecognized transformation: NotACipher/Blah/Blah\\E" )
    private
    void
    testBlockLenOf()
    {
        Map< String, Integer > expct = Lang.newMap( String.class, Integer.class,
            "AES/CBC/Blah", 16,
            "DESEDE/Blah/Blah", 8,
            "Blowfish/Blah/Blah", 8,
            "RC4/Blah/Blah", 0,
            "ARCFOUR/Blah/Blah", 0,
            "NotACipher/Blah/Blah", -1
        );

        for ( Map.Entry< String, Integer > e : expct.entrySet() )
        {
            state.equalInt( 
                e.getValue(), CryptoUtils.blockLengthOf( e.getKey() ) );
        }

        // Now also check failure of expectBlockLengthOf()
        CryptoUtils.expectBlockLengthOf( "NotACipher/Blah/Blah" );
    }

    @Test
    private
    void
    testIvLenOf()
    {
        Map< String, Integer > expct = Lang.newMap( String.class, Integer.class,
            "AES/CBC/Blah", 16,
            "DESede/CBC/Blah", 8,
            "DESede/ECB/Blah", 0,
            "DESede", 0,
            "Blowfish/CBC/Blah", 8,
            "RC4/Blah/Blah", 0,
            "NotACipher/Blah/Blah", -1
        );

        for ( Map.Entry< String, Integer > e : expct.entrySet() )
        {
            state.equalInt( 
                e.getValue(), CryptoUtils.ivLengthOf( e.getKey() ) );
        }
    }

    private
    KeyStore
    newKeyStore( char[] pass )
        throws Exception
    {
        KeyStore res = 
            KeyStore.getInstance( CryptoConstants.KEY_STORE_TYPE_JCEKS );

        res.load( null, pass );

        return res;
    }

    private
    void
    addKeys( KeyStore ks,
             char[] pass,
             int keyCount,
             KeyGenerator kg,
             String tmpl )
        throws Exception
    {
        for ( int i = 0; i < keyCount; ++i )
        {
            ks.setEntry( 
                String.format( tmpl, i ),
                new KeyStore.SecretKeyEntry( kg.generateKey() ),
                new KeyStore.PasswordProtection( pass )
            );
        }
    }

    @Test
    private
    void
    testGetKeyMap()
        throws Exception
    {
        char[] pass = "test".toCharArray();
        KeyStore ks = newKeyStore( pass );

        KeyGenerator kg = CryptoUtils.createKeyGenerator( "AES", 192 );
        addKeys( ks, pass, 2, kg, "accept-%016x" );
        addKeys( ks, pass, 2, kg, "reject-%016x" );

        Map< String, SecretKey > m = 
            CryptoUtils.getSecretKeys( ks, pass, "^accept-.*" );
        
        state.equalInt( 2, m.size() );
        state.noneNull( m, "m" );
        
        for ( int i = 0; i < 2; ++i )
        {
            String k = String.format( "accept-%016x", i );
            state.isTrue( m.containsKey( k ) );
        }
    }

    @Test
    private
    void
    testSecretKeyFromHex()
        throws Exception
    {
        SecretKey k = 
            CryptoUtils.createKeyGenerator( "AES", 256 ).generateKey();

        CharSequence hex = IoUtils.asHexString( k.getEncoded() );
        state.equalInt( 64, hex.length() );
        state.equal( "AES", k.getAlgorithm() );

        SecretKey k2 = CryptoUtils.secretKeyFromHex( hex, "AES" );
        state.equal( k, k2 );
    }

    @Test
    private
    void
    testIvFromHex()
        throws Exception
    {
        IvParameterSpec iv = CryptoUtils.createRandomIvSpec( 16 );

        CharSequence hex = IoUtils.asHexString( iv.getIV() );

        IoTests.assertEqual( iv.getIV(), CryptoUtils.ivFromHex( hex ).getIV() );
    }

    public
    static
    void
    assertDigests( MessageDigester d1,
                   MessageDigester d2,
                   boolean debug )
    {
        inputs.notNull( d1, "d1" );
        inputs.notNull( d2, "d2" );

        ByteBuffer d1Res = d1.digest();
        ByteBuffer d2Res = d2.digest();

        if ( debug )
        {
            CharSequence d1Str = IoUtils.asHexString( d1Res );
            CharSequence d2Str = IoUtils.asHexString( d2Res );
            code( "Asserting digests, d1:", d1Str, "; d2:", d2Str );
        }

        state.equal( d1Res, d2Res );
    }

    public
    static
    void
    assertDigests( MessageDigester d1,
                   MessageDigester d2 )
    {
        assertDigests( d1, d2, false );
    }

    static
    {
        ByteBuffer helloMd5 = ByteBuffer.allocate( 16 );

        String[] hexParts =
            "b1:94:6a:c9:24:92:d2:34:7c:62:35:b4:d2:61:11:84".split( ":" );

        for ( int i = 0, e = hexParts.length; i < e; ++i )
        {
            helloMd5.put( (byte) Integer.parseInt( hexParts[ i ], 16 ) );
        }

        helloMd5.position( 0 );

        HELLO_MD5_EXPCT = helloMd5.asReadOnlyBuffer();
    }
}
