package com.bitgirder.crypto;

import com.bitgirder.validation.Inputs;
import com.bitgirder.validation.State;

import com.bitgirder.log.CodeLoggers;

import com.bitgirder.io.IoUtils;
import com.bitgirder.io.Charsets;

import com.bitgirder.test.Test;

import java.nio.ByteBuffer;

import javax.crypto.Mac;
import javax.crypto.SecretKey;

@Test
public
final
class CryptoTests
{
    private static Inputs inputs = new Inputs();
    private static State state = new State();

    private static void code( Object... msg ) { CodeLoggers.code( msg ); }

    // Taken from the sample key in the AWS S3 docs, for what that's worth
    private final static String TEST_KEY_ASCII = 
        "uV3F3YluFJax1cknvbcGwgjvx4QpvB+leU8dUj2o";

    // Include the \n in HELLO_STR since we obtain HELLO_MD5_EXPCT from the
    // command: 'echo "hello" | openssl md5 -c'
    private final static String HELLO_STR = "hello\n";
    private final static ByteBuffer HELLO_MD5_EXPCT;

    @Test
    private
    void
    testMd5UtilMethod()
        throws Exception
    {
        ByteBuffer src = ByteBuffer.wrap( HELLO_STR.getBytes( "UTF-8" ) );
        ByteBuffer md5 = CryptoUtils.getMd5( src );
        
        state.equal( HELLO_MD5_EXPCT, md5 );
    }

    @Test
    private
    void
    testMessageDigesterSingleCall()
        throws Exception
    {
        ByteBuffer src = ByteBuffer.wrap( HELLO_STR.getBytes( "UTF-8" ) );
        MessageDigester dig = CryptoUtils.createDigester( "md5" );

        dig.update( src );
        state.equal( HELLO_MD5_EXPCT, dig.digest() );
    }

    @Test
    private
    void
    testMessageDigesterMultiBufs()
        throws Exception
    {
        ByteBuffer src = ByteBuffer.wrap( HELLO_STR.getBytes( "UTF-8" ) );
        MessageDigester dig = CryptoUtils.createDigester( "md5" );

        ByteBuffer b1 = src.duplicate();
        b1.limit( 2 );

        ByteBuffer b2 = src.duplicate();
        b2.position( 2 );

        ByteBuffer md5 = IoUtils.digest( dig, true, b1, b2 );

        state.equal( HELLO_MD5_EXPCT, md5 );
    }

    // Expected string was generated by the command:
    //
    //  $ echo "sign-this-string" | openssl dgst -sha256 -hmac 'uV3F3YluFJax1cknvbcGwgjvx4QpvB+leU8dUj2o'
    //
    @Test
    private
    void
    testHmacSha256()
        throws Exception
    {
        SecretKey key = CryptoUtils.asSecretKey( TEST_KEY_ASCII, "HmacSHA256" );
        Mac mac = CryptoUtils.expectMac( key, "HmacSHA256" );

        ByteBuffer toSign = Charsets.UTF_8.asByteBuffer( "sign-this-string\n" );
        ByteBuffer sig = CryptoUtils.sign( toSign, mac );

        state.equalString( 
            "4a6a1d3ecc981c8fde0aa8d98b88d9d164d45978454875fa44fdf2f3c1464e9a", 
            IoUtils.asHexString( sig )
        );
    }

    @Test
    private
    void
    testGetAlgorithm()
    {
        // Not all of the transform strings tested below are actually valid from
        // a JCE perspective, but we only care about asserting our parsing of
        // them
        for ( String s : 
                new String[] { "AES", "AES/CBC", "AES/CBC/PKCS5Padding" } )
        {
            state.equalString( "AES", CryptoUtils.getAlgorithm( s ) );
        }
    }

    @Test( expected = IllegalArgumentException.class,
           expectedPattern = 
            "Cannot determine algorithm name in transformation: " )
    private
    void
    testGetAlgorithmWithEmptyAlgNameFails()
    {
        CryptoUtils.getAlgorithm( "" );
    }

    @Test( expected = IllegalArgumentException.class,
           expectedPattern = 
            "Cannot determine algorithm name in transformation: " +
            "/CBC/NoPadding" )
    private
    void
    testGetAlgorithmWithMissingAlgNameFails()
    {
        CryptoUtils.getAlgorithm( "/CBC/NoPadding" );
    }

    public
    static
    void
    assertDigests( MessageDigester d1,
                   MessageDigester d2,
                   boolean debug )
    {
        inputs.notNull( d1, "d1" );
        inputs.notNull( d2, "d2" );

        ByteBuffer d1Res = d1.digest();
        ByteBuffer d2Res = d2.digest();

        if ( debug )
        {
            CharSequence d1Str = IoUtils.asHexString( d1Res );
            CharSequence d2Str = IoUtils.asHexString( d2Res );
            code( "Asserting digests, d1:", d1Str, "; d2:", d2Str );
        }

        state.equal( d1Res, d2Res );
    }

    public
    static
    void
    assertDigests( MessageDigester d1,
                   MessageDigester d2 )
    {
        assertDigests( d1, d2, false );
    }

    static
    {
        ByteBuffer helloMd5 = ByteBuffer.allocate( 16 );

        String[] hexParts =
            "b1:94:6a:c9:24:92:d2:34:7c:62:35:b4:d2:61:11:84".split( ":" );

        for ( int i = 0, e = hexParts.length; i < e; ++i )
        {
            helloMd5.put( (byte) Integer.parseInt( hexParts[ i ], 16 ) );
        }

        helloMd5.position( 0 );

        HELLO_MD5_EXPCT = helloMd5.asReadOnlyBuffer();
    }
}
